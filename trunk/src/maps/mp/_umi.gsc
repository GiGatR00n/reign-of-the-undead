/******************************************************************************
 *    Reign of the Undead, v2.x
 *
 *    Copyright (c) 2010-2013 Reign of the Undead Team.
 *    See AUTHORS.txt for a listing.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a copy
 *    of this software and associated documentation files (the "Software"), to
 *    deal in the Software without restriction, including without limitation the
 *    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *    sell copies of the Software, and to permit persons to whom the Software is
 *    furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice shall be included in
 *    all copies or substantial portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *
 *    The contents of the end-game credits must be kept, and no modification of its
 *    appearance may have the effect of failing to give credit to the Reign of the
 *    Undead creators.
 *
 *    Some assets in this mod are owned by Activision/Infinity Ward, so any use of
 *    Reign of the Undead must also comply with Activision/Infinity Ward's modtools
 *    EULA.
 ******************************************************************************/
/** @file _umi.gsc The RotU implementation of the unified mapping interface as
 * specified in @code maps\mp\_unified_mapping_interface.gsc @endcode
 *
 * Attention Mappers: Include this file in your main map file--
 *                    not @code maps\mp\_unified_mapping_interface.gsc @endcode
 */

#include scripts\include\array;
#include scripts\include\data;
#include scripts\include\entities;
#include scripts\include\hud;
#include scripts\include\matrix;
#include scripts\include\utility;

//
// Unified Mapping Interface (UMI) Public Functions
//
// Map makers can count on these functions being defined in every mod that uses
// the UMI.  However, any given function may not actually have a use in the mod,
// e.g. a call to buildParachutePickup() won't cause any compile or runtime errors
// when the map is run in RotU, but that call will have no effect as parachute drops
// aren't part of RotU.
//

/**
 * @brief Returns the lower-cased name of the mod that is trying to load the map
 *
 * @returns string The name of the mod, e.g. "rotu", "rozo", etc
 * @since RotU 2.2.1
 */
modName()
{
    if (isDefined(level.modName)) {return level.modName;}
    else {
        level.modName = "rotu";
        return level.modName;
    }
}

/**
 * @brief Returns the native type of the map being loaded
 *
 * @returns string The native type of the map, e.g. "rotu", "rozo", etc.
 * @since RotU 2.2.1
 */
nativeMapType()
{
    if (isDefined(level.nativeMapType)) {return level.nativeMapType;}
    else {return "";}
}

/**
 * @brief Sets the native type of the map being loaded
 *
 * @param nativeMapType string The native type of the map, e.g. "rotu", "rozo", etc.
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
setNativeMapType(nativeMapType)
{
    level.nativeMapType = nativeMapType;
}

/**
 * @brief UMI Converts CSV waypoints to BTD waypoints, and prints them to the server log
 * It prints the BTD function, but will require the timecodes to be removed from the
 * front the the line, as well as any extraneous info printed to the log at the
 * same time by other functions.
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devDumpCsvWaypointsToBtd()
{
    debugPrint("in _umi::devDumpCsvWaypointsToBtd()", "fn", level.nonVerbose);

    wp = [];
    wpCount = 0;

    fileName =  "waypoints/"+ tolower(getdvar("mapname")) + "_wp.csv";
    wpCount = int(TableLookup(fileName, 0, 0, 1));

    if ((!isDefined(wpCount)) || (wpCount == 0)) {
        noticePrint("No csv waypoints in fastfile, nothing to dump.");
        return;
    }

    wpFilename = tolower(getdvar("mapname"))+"_waypoints.gsc";
    logPrint("// BTD-style load_waypoints() function for file " + wpFilename + " generated by RotU\n");
    logPrint("// based on waypoints compiled into the map's fast file.\n");
    logPrint("//\n");
    logPrint("// These waypoints can be edited and then used to override the waypoints in the fast file\n");
    logPrint("// using _umi::setPreferBtdWaypoints(true)\n");
    logPrint("// Alternatively, you may use these waypoints, and recompile the fast file without the waypoints.\n");
    logPrint("//\n");
    logPrint("// N.B. You will need to delete the timecodes at the beginning of these lines!\n");
    logPrint("//\n");

    logPrint("load_waypoints()\n");
    logPrint("{\n");
    logPrint("    level.waypoints = [];\n");
    logPrint("    \n");

    for (i=0; i<level.WpCount; i++) {
        wpIndex = i;
        csvIndex = i + 1;
        strOrigin = TableLookup(fileName, 0, csvIndex, 1);
        originTokens = strtok(strOrigin, " ");
        x = atof(originTokens[0]);
        y = atof(originTokens[1]);
        z = atof(originTokens[2]);

        logPrint("    level.waypoints["+wpIndex+"] = spawnstruct();\n");
        logPrint("    level.waypoints["+wpIndex+"].origin = ("+x+","+y+","+z+");\n");

        strLinked = TableLookup(fileName, 0, csvIndex, 2);
        linkedTokens = strtok(strLinked, " ");
        childCount = linkedTokens.size;
        logPrint("    level.waypoints["+wpIndex+"].childCount = "+childCount+";\n");

        for (j=0; j<childCount; j++) {
            logPrint("    level.waypoints["+wpIndex+"].children["+j+"] = "+linkedTokens[j]+";\n");
        }
    }

    logPrint("    \n");
    logPrint("    level.waypointCount = level.waypoints.size;\n");
    logPrint("}\n");
}

/**
 * @brief UMI Converts BTD waypoints to CSV waypoints, and prints them to the server log
 * It prints the contents of the *.csv file, but will require the timecodes to be removed from the
 * front the the line, as well as any extraneous info printed to the log at the
 * same time by other functions.
 *
 * This function must be called immediately after load_waypoints(), e.g.
 * @code
 * maps\mp\mp_burgundy_bulls_waypints::load_waypoints();
 * devDumpBtdWaypointsToCsv();
 * @endcode
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devDumpBtdWaypointsToCsv()
{
    debugPrint("in _umi::devDumpBtdWaypointsToCsv()", "fn", level.nonVerbose);

    if ((!isDefined(level.waypoints)) || (level.waypoints.size == 0)) {
        noticePrint("No BTD waypoints in memory, nothing to dump.");
        return;
    }

    fileName =  "waypoints/"+ tolower(getdvar("mapname")) + "_wp.csv";
    logPrint("// CSV-style waypoints generated by RotU from BTD-style waypoints.\n");
    logPrint("// Save these lines in a file named " + fileName + "\n");
    logPrint("//\n");
    logPrint("// These waypoints can then be compiled into the map's fast file.\n");
    logPrint("//\n");
    logPrint("// N.B. You will need to delete the timecodes at the beginning of these lines!\n");
    logPrint("//\n");

    logPrint("0,"+level.waypoints.size+",0\n");
    for (i=0; i<level.waypoints.size; i++) {
        csvIndex = i+1;
        x = level.waypoints[i].origin[0];
        y = level.waypoints[i].origin[1];
        z = level.waypoints[i].origin[2];
        linkedWaypoints = level.waypoints[i].children[0];
        for (j=1; j<level.waypoints[i].childCount; j++) {
            linkedWaypoints = linkedWaypoints + " " + level.waypoints[i].children[j];
        }
        logPrint(csvIndex+","+x+" "+y+" "+z+","+linkedWaypoints+"\n");
    }
}

/**
 * @brief UMI draws all possible spawnpoints on the map
 * This is useful when placing tradespawns to ensure you don't block a spawning player
 * @threaded
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devDrawAllPossibleSpawnpoints()
{
    debugPrint("in _umi::devDrawAllPossibleSpawnpoints()", "fn", level.nonVerbose);

    // mark RotU-style spawngroups by targetname
    for (i=0; i<20; i++) {
        targetname = "spawngroup" + i;
        ents = getentarray(targetname, "targetname");
        for (j=0; j<ents.size; j++) {
            devDrawLaser("red", ents[j].origin, (0,0,1));
        }
    }
    // mark RotU-style spawngroups by classname
    for (i=0; i<20; i++) {
        classname = "spawngroup" + i;
        ents = getentarray(classname, "classname");
        for (j=0; j<ents.size; j++) {
            devDrawLaser("red", ents[j].origin, (0,0,1));
        }
    }
    // mark the Cod4 stock spawnpoints
    codSpawnpointClasses[0] = "mp_tdm_spawn";
    codSpawnpointClasses[1] = "mp_tdm_spawn_allies_start";
    codSpawnpointClasses[2] = "mp_tdm_spawn_axis_start";
    codSpawnpointClasses[3] = "mp_dm_spawn";
    codSpawnpointClasses[4] = "mp_global_intermission";
    for (i=0; i<codSpawnpointClasses.size; i++) {
        ents = getentarray(codSpawnpointClasses[i], "classname");
        for (j=0; j<ents.size; j++) {
            devDrawLaser("red", ents[j].origin, (0,0,1));
        }
    }
}

/**
 * @brief UMI deletes unused entities from CoD4 stock maps
 * This function must be called before we build our own tradespawns
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
deleteUnusedEntitiesFromStockMaps()
{
    debugPrint("in _umi::deleteUnusedEntitiesFromStockMaps()", "fn", level.nonVerbose);

    // delete the Cod4 stock unused entities by targetname
    codUnusedEntitesTargetnames[0] = "hq_hardpoint";
    codUnusedEntitesTargetnames[1] = "flag_primary";
    codUnusedEntitesTargetnames[2] = "sab_bomb_axis";
    codUnusedEntitesTargetnames[3] = "sab_bomb_allies";
    codUnusedEntitesTargetnames[4] = "sab_bomb_defuse_allies";
    codUnusedEntitesTargetnames[5] = "sab_bomb_defuse_axis";
    codUnusedEntitesTargetnames[6] = "sab_bomb";
    codUnusedEntitesTargetnames[7] = "sab_bomb_pickup_trig";
    codUnusedEntitesTargetnames[8] = "radiotrigger";
    codUnusedEntitesTargetnames[9] = "flag_descriptor";
    codUnusedEntitesTargetnames[10] = "sd_bomb";
    codUnusedEntitesTargetnames[11] = "bombtrigger";
    codUnusedEntitesTargetnames[12] = "bombzone";
    codUnusedEntitesTargetnames[13] = "sd_bomb_pickup_trig";
    codUnusedEntitesTargetnames[14] = "ctf_flag_allies";
    codUnusedEntitesTargetnames[15] = "ctf_flag_axis";
    codUnusedEntitesTargetnames[16] = "exploder";

    for (i=0; i<codUnusedEntitesTargetnames.size; i++) {
        ents = getentarray(codUnusedEntitesTargetnames[i], "targetname");
        for (j=0; j<ents.size; j++) {
            ents[j] delete();
        }
    }

    // delete the Cod4 stock unused entities by classname
    codUnusedEntitesClassnames[0] = "script_model";
    codUnusedEntitesClassnames[1] = "trigger_radius";
    codUnusedEntitesClassnames[2] = "trigger_use";
    codUnusedEntitesClassnames[3] = "script_origin";
    codUnusedEntitesClassnames[3] = "script_brushmodel";

    for (i=0; i<codUnusedEntitesClassnames.size; i++) {
        ents = getentarray(codUnusedEntitesClassnames[i], "classname");
        for (j=0; j<ents.size; j++) {
            // Do not delete destructibles like exploding cars from stock maps
            if ((isDefined(ents[j].targetname)) && (ents[j].targetname == "destructible")) {continue;}

            ents[j] delete();
        }
    }
//    maps\mp\_umi::devDumpEntities();
}


/**
 * @brief UMI draws the waypoints on the map
 * @threaded
 *
 * works with playMod.bat with:
 * +set developer 1 +set developer_script 1 +set dedicated 0
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devDrawWaypoints()
{
    debugPrint("in _umi::devDrawWaypoints()", "fn", level.nonVerbose);

    noticePrint("Map: Drawing waypoints requires +set developer 1 +set developer_script 1");

    // wait until someone is in the game to see the waypoints before we draw them
    while (level.activePlayers == 0) {
        wait 0.5;
    }

    for (i=0; i<level.Wp.size; i++) {
        devDrawLaser("green", level.Wp[i].origin, (0,0,1));
    }

    player = scripts\include\adminCommon::getPlayerByShortGuid(getDvar("admin_forced_guid"));

    // Set up HUD elements
    verticalOffset = 80;

    waypointIdHud = newClientHudElem(player);
    waypointIdHud.elemType = "font";
    waypointIdHud.font = "default";
    waypointIdHud.fontscale = 1.4;
    waypointIdHud.x = -16;
    waypointIdHud.y = verticalOffset;
    waypointIdHud.glowAlpha = 1;
    waypointIdHud.hideWhenInMenu = true;
    waypointIdHud.archived = false;
    waypointIdHud.alignX = "right";
    waypointIdHud.alignY = "middle";
    waypointIdHud.horzAlign = "right";
    waypointIdHud.vertAlign = "top";
    waypointIdHud.alpha = 1;
    waypointIdHud.glowColor = (0,0,1);
    waypointIdHud.label = &"ZOMBIE_WAYPOINT_ID";
    waypointIdHud setValue(0);

    playerXHud = newClientHudElem(player);
    playerXHud.elemType = "font";
    playerXHud.font = "default";
    playerXHud.fontscale = 1.4;
    playerXHud.x = -16;
    playerXHud.y = verticalOffset + 18*1;
    playerXHud.glowAlpha = 1;
    playerXHud.hideWhenInMenu = true;
    playerXHud.archived = false;
    playerXHud.alignX = "right";
    playerXHud.alignY = "middle";
    playerXHud.horzAlign = "right";
    playerXHud.vertAlign = "top";
    playerXHud.alpha = 1;
    playerXHud.glowColor = (0,0,1);
    playerXHud.label = &"ZOMBIE_PLAYER_X";
    playerXHud setValue(player.origin[0]);

    playerYHud = newClientHudElem(player);
    playerYHud.elemType = "font";
    playerYHud.font = "default";
    playerYHud.fontscale = 1.4;
    playerYHud.x = -16;
    playerYHud.y = verticalOffset + 18*2;
    playerYHud.glowAlpha = 1;
    playerYHud.hideWhenInMenu = true;
    playerYHud.archived = false;
    playerYHud.alignX = "right";
    playerYHud.alignY = "middle";
    playerYHud.horzAlign = "right";
    playerYHud.vertAlign = "top";
    playerYHud.alpha = 1;
    playerYHud.glowColor = (0,0,1);
    playerYHud.label = &"ZOMBIE_PLAYER_Y";
    playerYHud setValue(player.origin[1]);

    playerZHud = newClientHudElem(player);
    playerZHud.elemType = "font";
    playerZHud.font = "default";
    playerZHud.fontscale = 1.4;
    playerZHud.x = -16;
    playerZHud.y = verticalOffset + 18*3;
    playerZHud.glowAlpha = 1;
    playerZHud.hideWhenInMenu = true;
    playerZHud.archived = false;
    playerZHud.alignX = "right";
    playerZHud.alignY = "middle";
    playerZHud.horzAlign = "right";
    playerZHud.vertAlign = "top";
    playerZHud.alpha = 1;
    playerZHud.glowColor = (0,0,1);
    playerZHud.label = &"ZOMBIE_PLAYER_Z";
    playerZHud setValue(player.origin[2]);

    iPrintLnBold("Waypoint links are drawn 10 units above their origin for better visibility");
    while (1) {
        nearestWp = -1;
        closestWp = -1;
        nearestDistance = 9999999999;
        for (i=0; i<level.WpCount; i++) {
            for (j=0; j<level.Wp[i].linked.size; j++) {
//                 Line( <start>, <end>, <color>, <depthTest>, <duration> )
                line(level.Wp[i].origin + (0,0,10), level.Wp[i].linked[j].origin + (0,0,10), (0.9, 0.7, 0.6), false, 25);
            }
            distance = distancesquared(player.origin, level.Wp[i].origin);
            if(distance < nearestDistance) {
                nearestDistance = distance;
                nearestWp = i;
            }
            if (i == (level.WpCount - 1)) {
                closestWp = nearestWp;
            }
            location = player.origin + (vectorNormalize(anglesToForward(player.angles)) * 2000) - (0,0,20);
            waypointIdHud setValue(nearestWp);
            playerXHud setValue(player.origin[0]);
            playerYHud setValue(player.origin[1]);
            playerZHud setValue(player.origin[2]);
        }
        wait 0.05;
    }
}

/**
 * @brief UMI writes the player's current position to the server log
 * Intended to help add/edit waypoints to maps lacking them.  Should be called
 * from an admin command, or perhaps from a keybinding.
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devRecordWaypoint()
{
    debugPrint("in _umi::devRecordWaypoint()", "fn", level.nonVerbose);

    x = self.origin[0];
    y = self.origin[1];
    z = self.origin[2];

    msg = "Recorded waypoint: origin: ("+x+","+y+","+z+")";
    noticePrint(msg);
    iPrintLnBold(msg);
}

/**
 * @brief UMI gives a player a weapons shop that they can emplace
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devGiveEquipmentShop()
{
    debugPrint("in _umi::devGiveEquipmentShop()", "fn", level.nonVerbose);

    if (!isDefined(level.devEquipmentShops)) {level.devEquipmentShops = [];}

    shop = spawn("script_model", (0,0,0));
    shop setModel("ad_sodamachine");
    level.devEquipmentShops[level.devEquipmentShops.size] = shop;

    self.carryObj = shop;
    // we intentionally pick it up off-center so the player can see where they
    // are going
    self.carryObj.origin = self.origin + AnglesToForward(self.angles)*80;

    self.carryObj.angles = self.angles + (0,-90,0);
    self.carryObj.master = self;
    self.carryObj linkto(self);
    self.carryObj setcontents(2);

    level scripts\players\_usables::addUsable(shop, "equipmentShop", "Press [use] to pickup equipment shop", 80);
    self.canUse = false;
    self disableweapons();
    self thread devEmplaceEquipmentShop();
}

/**
 * @brief UMI emplaces an equipment shop a player is carrying
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devEmplaceEquipmentShop()
{
    debugPrint("in _umi::devEmplaceEquipmentShop()", "fn", level.nonVerbose);

    while (1) {
        if (self attackbuttonpressed()) {
            // self.carryObj.origin is the origin of xmodel's coord system, which
            // is the left rear base corner of the soda machine, which is about
            // 40.4 units wide and 31.6 units deep.

            // a, b, and c lie in the base plane of the model, b and c the front
            // left and right corners, respectively, and a bisects the rear face
            a = zeros(2,1);
            setValue(a,1,1,20.2);  // x
            setValue(a,2,1,0);     // y
            b = zeros(2,1);
            setValue(b,1,1,0);     // x
            setValue(b,2,1,-31.6); // y
            c = zeros(2,1);
            setValue(c,1,1,40.4);  // x
            setValue(c,2,1,-31.6); // y

            // d, e, and f are a, b, and c, repspectively, translated into world coordinates
            phi = self.carryObj.angles[1]; // phi is the angle the xmodel is rotated through

            R = eye(2);
            setValue(R,1,1,cos(phi));
            setValue(R,1,2,-1*sin(phi));
            setValue(R,2,1,sin(phi));
            setValue(R,2,2,cos(phi));

            // apply the rotation matrix
            dM = matrixMultiply(R, a);
            eM = matrixMultiply(R, b);
            fM = matrixMultiply(R, c);
            d = self.carryObj.origin + (value(dM,1,1),value(dM,2,1),0);
            e = self.carryObj.origin + (value(eM,1,1),value(eM,2,1),0);
            f = self.carryObj.origin + (value(fM,1,1),value(fM,2,1),0);

            // we trace 50 units above to 50 units below d, e, and f, and the trace
            // position will give us the points, g,h, and l above/below d,e, and f
            // that intersect the world surface
            result = bulletTrace(d + (0,0,100), d - (0,0,100), false, self.carryObj);
            g = result["position"];
            result = bulletTrace(e + (0,0,100), e - (0,0,100), false, self.carryObj);
            h = result["position"];
            result = bulletTrace(f + (0,0,100), f - (0,0,100), false, self.carryObj);
            l = result["position"];

            // now g, h, and l define a plane that approximates the local world surface,
            // so we find the surface normal
            hg = h - g; // h relative to g
            lg = l - g; // l relative to g

            s = zeros(3,1);
            setValue(s,1,1,hg[0]);  // x
            setValue(s,2,1,hg[1]);  // y
            setValue(s,3,1,hg[2]);  // z
            t = zeros(3,1);
            setValue(t,1,1,lg[0]);  // x
            setValue(t,2,1,lg[1]);  // y
            setValue(t,3,1,lg[2]);  // z
            normalM = matrixCross(s, t);

            // standard basis vectors in world coordinate system
            i = (1,0,0);
            j = (0,1,0);
            k = (0,0,1);

            // [i|j|k]Prime are the basis vectors for the rotated coordinate system
            kPrime = vectorNormalize((value(normalM,1,1), value(normalM,2,1), value(normalM,3,1)));
            iPrime = vectorNormalize(l-h);
            u = zeros(3,1);
            setValue(u,1,1,iPrime[0]);  // x
            setValue(u,2,1,iPrime[1]);  // y
            setValue(u,3,1,iPrime[2]);  // z
            jPrimeM = matrixCross(u, normalM);
            jPrime = vectorNormalize((value(jPrimeM,1,1), value(jPrimeM,2,1), value(jPrimeM,3,1)));

            // calculate the new origin (the left-rear corner of the re-positioned soda machine)
            newOrigin = h + (jPrime*-31.6);
            self.carryObj.origin = newOrigin;

            // align the soda machine's x-axis with the computed x-axis
            phi = scripts\players\_turrets::angleBetweenTwoVectors(k, kPrime*(0,1,1));
            self.carryObj.angles = vectorToAngles(iPrime);

            // now align the crate's y-axis with the computed y-axis
            z = anglesToUp(self.carryObj.angles);
            phi = scripts\players\_turrets::angleBetweenTwoVectors(z, kPrime);
            self.carryObj.angles = self.carryObj.angles + (0,0,phi); // phi rotates about x-axis

            // ensure we rotated the crate properly to align the y-axis
            y = anglesToRight(self.carryObj.angles);
            beta = scripts\players\_turrets::angleBetweenTwoVectors(y, jPrime);
            if (beta > phi) {
                // phi should have been negated!
                self.carryObj.angles = self.carryObj.angles + (0,0,-2*phi); // phi rotates about x-axis
            }

            self.carryObj unlink();
            wait .05;
            self.canUse = true;
            self enableweapons();
            return;
        }
        wait 0.1;
    }
}

/**
 * @brief UMI draws a colored laser  at the location and direction specified
 *
 * @param color string The color of the laser: red, green, blue, white, yellow, magenta, cyan
 * @param origin vector The location to place the laser
 * @param direction vector the direction to shine the laser
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devDrawLaser(color, origin, direction)
{
    debugPrint("in _umi::devDrawLaser()", "fn", level.lowVerbosity);

    if (color == "red") {
        playFx(level.redLaserSight, origin, direction);
    } else if (color == "green") {
        playFx(level.greenLaserSight, origin, direction);
    } else if (color == "blue") {
        playFx(level.blueLaserSight, origin, direction);
    } else if (color == "white") {
        playFx(level.redLaserSight, origin, direction);
        playFx(level.greenLaserSight, origin, direction);
        playFx(level.blueLaserSight, origin, direction);
    } else if (color == "yellow") {
        playFx(level.redLaserSight, origin, direction);
        playFx(level.greenLaserSight, origin, direction);
    } else if (color == "magenta") {
        playFx(level.redLaserSight, origin, direction);
        playFx(level.blueLaserSight, origin, direction);
    } else if (color == "cyan") {
        playFx(level.greenLaserSight, origin, direction);
        playFx(level.blueLaserSight, origin, direction);
    }
}

/**
 * @brief UMI emplaces a weapon shop a player is carrying
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devEmplaceWeaponShop()
{
    debugPrint("in _umi::devEmplaceWeaponShop()", "fn", level.nonVerbose);

    while (1) {
        if (self attackbuttonpressed()) {
            // a, b, and c lie in the base plane of the model, b and c the front
            // left and right corners, respectively, and a bisects the rear face
            a = zeros(2,1);
            setValue(a,1,1,0);   // x
            setValue(a,2,1,16);  // y
            b = zeros(2,1);
            setValue(b,1,1,-20); // x
            setValue(b,2,1,-16); // y
            c = zeros(2,1);
            setValue(c,1,1,20);  // x
            setValue(c,2,1,-16); // y

            // d, e, and f are a, b, and c, repspectively, translated into world coordinates
            phi = self.carryObj.angles[1]; // phi is the angle the xmodel is rotated through

            R = eye(2);
            setValue(R,1,1,cos(phi));
            setValue(R,1,2,-1*sin(phi));
            setValue(R,2,1,sin(phi));
            setValue(R,2,2,cos(phi));

            // apply the rotation matrix
            dM = matrixMultiply(R, a);
            eM = matrixMultiply(R, b);
            fM = matrixMultiply(R, c);
            d = self.carryObj.origin + (value(dM,1,1),value(dM,2,1),0);
            e = self.carryObj.origin + (value(eM,1,1),value(eM,2,1),0);
            f = self.carryObj.origin + (value(fM,1,1),value(fM,2,1),0);

            // we trace 50 units above to 100 units below d, e, and f, and the trace
            // position will give us the points, g, h, and l above/below d, e, and f
            // that intersect the world surface
            result = bulletTrace(d + (0,0,50), d - (0,0,100), false, self.carryObj);
            g = result["position"];
            result = bulletTrace(e + (0,0,50), e - (0,0,100), false, self.carryObj);
            h = result["position"];
            result = bulletTrace(f + (0,0,50), f - (0,0,100), false, self.carryObj);
            l = result["position"];

            // now g, h, and l define a plane that approximates the local world surface,
            // so we find the surface normal
            hg = h - g; // h relative to g
            lg = l - g; // l relative to g

            s = zeros(3,1);
            setValue(s,1,1,hg[0]);  // x
            setValue(s,2,1,hg[1]);  // y
            setValue(s,3,1,hg[2]);  // z
            t = zeros(3,1);
            setValue(t,1,1,lg[0]);  // x
            setValue(t,2,1,lg[1]);  // y
            setValue(t,3,1,lg[2]);  // z
            normalM = matrixCross(s, t);

            // standard basis vectors in world coordinate system
            i = (1,0,0);
            j = (0,1,0);
            k = (0,0,1);

            // [i|j|k]Prime are the basis vectors for the rotated coordinate system
            kPrime = vectorNormalize((value(normalM,1,1), value(normalM,2,1), value(normalM,3,1)));
            iPrime = vectorNormalize(l-h);
            u = zeros(3,1);
            setValue(u,1,1,iPrime[0]);  // x
            setValue(u,2,1,iPrime[1]);  // y
            setValue(u,3,1,iPrime[2]);  // z
            jPrimeM = matrixCross(u, normalM);
            jPrime = vectorNormalize((value(jPrimeM,1,1), value(jPrimeM,2,1), value(jPrimeM,3,1)));

            // calculate the new origin (the center of the re-positioned crate)
            newOrigin = h + (jPrime*-31.6);
            midpoint = h + ((l-h) * 0.5);
            newOrigin = midpoint + ((g-midpoint) * 0.5);
            self.carryObj.origin = newOrigin;

            // align the crate's x-axis with the computed x-axis
            phi = scripts\players\_turrets::angleBetweenTwoVectors(k, kPrime*(0,1,1));
            self.carryObj.angles = vectorToAngles(iPrime);

            // now align the crate's y-axis with the computed y-axis
            z = anglesToUp(self.carryObj.angles);
            phi = scripts\players\_turrets::angleBetweenTwoVectors(z, kPrime);
            self.carryObj.angles = self.carryObj.angles + (0,0,phi); // phi rotates about x-axis

            // ensure we rotated the crate properly to align the y-axis
            y = anglesToRight(self.carryObj.angles);
            beta = scripts\players\_turrets::angleBetweenTwoVectors(y, jPrime);
            if (beta > phi) {
                // phi should have been negated!
                self.carryObj.angles = self.carryObj.angles + (0,0,-2*phi); // phi rotates about x-axis
            }

            self.carryObj unlink();
            wait .05;
            self.canUse = true;
            self enableweapons();
            return;
        }
        wait 0.1;
    }
}


/**
 * @brief UMI permits a player pick up and move am equipment shop
 *
 * @param shop entity The shop to pick up
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devMoveEquipmentShop(shop)
{
    debugPrint("in _umi::devMoveEquipmentShop()", "fn", level.nonVerbose);

    self scripts\players\_usables::removeUsable(shop);

    self.carryObj = shop;
    self.carryObj.origin = self.origin + AnglesToForward(self.angles)*80;
    self.carryObj.angles = self.angles + (0,-90,0);
    self.carryObj.master = self;
    self.carryObj linkto(self);
    self.carryObj setcontents(2);

    level scripts\players\_usables::addUsable(shop, "equipmentShop", "Press [use] to pickup equipment shop", 80);
    self.canUse = false;
    self disableweapons();
    self thread devEmplaceEquipmentShop();
}

/**
 * @brief UIM permits a player pick up and move a weapon shop
 *
 * @param shop entity The shop to pick up
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devMoveWeaponShop(shop)
{
    debugPrint("in _umi::devMoveWeaponShop()", "fn", level.nonVerbose);

    self scripts\players\_usables::removeUsable(shop);

    self.carryObj = shop;
    self.carryObj.origin = self.origin + AnglesToForward(self.angles)*80;
    self.carryObj.angles = self.angles + (0,-90,0);
    self.carryObj.master = self;
    self.carryObj linkto(self);
    self.carryObj setcontents(2);

    level scripts\players\_usables::addUsable(shop, "weaponsShop", "Press [use] to pickup weapon shop", 80);
    self.canUse = false;
    self disableweapons();
    self thread devEmplaceWeaponShop();
}

/**
 * @brief UMI gives a player a weapons shop that they can emplace
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devGiveWeaponsShop()
{
    debugPrint("in _umi::devGiveWeaponsShop()", "fn", level.nonVerbose);

    if (!isDefined(level.devWeaponShops)) {level.devWeaponShops = [];}

    shop = spawn("script_model", (0,0,0));
    shop setModel("com_plasticcase_green_big");
    level.devWeaponShops[level.devWeaponShops.size] = shop;

    self.carryObj = shop;
    self.carryObj.origin = self.origin + AnglesToForward(self.angles)*80;

    self.carryObj.angles = self.angles + (0,-90,0);
    self.carryObj.master = self;
    self.carryObj linkto(self);
    self.carryObj setcontents(2);

    level scripts\players\_usables::addUsable(shop, "weaponsShop", "Press [use] to pickup weapon shop", 80);
    self.canUse = false;
    self disableweapons();
    self thread devEmplaceWeaponShop();
}


/**
 * @brief UMI deletes the shop closest to the player
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devDeleteClosestShop()
{
    debugPrint("in _umi::devDeleteClosestShop()", "fn", level.nonVerbose);

    // Find closest equipment shop
    closestEquipmentDistance = 999999;
    closestEquipmentShopIndex = -1;
    if (isDefined(level.devEquipmentShops)) {
        noticePrint("Pre level.devEquipmentShops.size: " + level.devEquipmentShops.size);
        for (i=0; i<level.devEquipmentShops.size; i++) {
            distanceProxy = distanceSquared(self.origin, level.devEquipmentShops[i].origin);
            if (distanceProxy < closestEquipmentDistance) {
                closestEquipmentDistance = distanceProxy;
                closestEquipmentShopIndex = i;
            }
        }
    }

    // Find closest weapon shop
    closestWeaponDistance = 999999;
    closestWeaponShopIndex = -1;
    if (isDefined(level.devWeaponShops)) {
        noticePrint("Pre level.devWeaponShops.size: " + level.devWeaponShops.size);
        for (i=0; i<level.devWeaponShops.size; i++) {
            distanceProxy = distanceSquared(self.origin, level.devWeaponShops[i].origin);
            if (distanceProxy < closestWeaponDistance) {
                closestWeaponDistance = distanceProxy;
                closestWeaponShopIndex = i;
            }
        }
    }

    // Delete the closest shop
    if (closestEquipmentDistance < closestWeaponDistance) {
        // delete equipment shop
        level scripts\players\_usables::removeUsable(level.devEquipmentShops[closestEquipmentShopIndex]);
        level.devEquipmentShops[closestEquipmentShopIndex] delete();
        level.devEquipmentShops = removeElementByIndex(level.devEquipmentShops, closestEquipmentShopIndex);
        noticePrint("Post level.devEquipmentShops.size: " + level.devEquipmentShops.size);
    } else {
        // delete weapon shop
        level scripts\players\_usables::removeUsable(level.devWeaponShops[closestWeaponShopIndex]);
        level.devWeaponShops[closestWeaponShopIndex] delete();
        level.devWeaponShops = removeElementByIndex(level.devWeaponShops, closestWeaponShopIndex);
        noticePrint("Post level.devWeaponShops.size: " + level.devWeaponShops.size);
    }

}

/**
 * @brief UMI writes a tradespawn file to the server log
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devSaveTradespawns()
{
    debugPrint("in _umi::devSaveTradespawns()", "fn", level.nonVerbose);

    if (level.devWeaponShops.size != level.devEquipmentShops.size) {
        msg = "Map: You must have an equal number of weapon and equipment shops!";
        errorPrint(msg);
        iPrintLnBold(msg);
        return;
    }

    mapName =  tolower(getdvar("mapname"));
    logPrint("// =============================================================================\n");
    logPrint("// File Name = '"+mapname+"_tradespawns.gsc'\n");
    logPrint("// Map Name = '"+mapname+"'\n");
    logPrint("// =============================================================================\n");
    logPrint("//\n");
    logPrint("// This file was generated by the RotU admin development command 'Save Tradespawns'\n");
    logPrint("//\n");
    logPrint("// =============================================================================\n");
    logPrint("//\n");
    logPrint("// This file contains the tradespawns (equipment & weapon shop locations) for\n");
    logPrint("// the map '" + mapName + "'\n");
    logPrint("//\n");
    logPrint("// N.B. You will need to delete the timecodes at the beginning of these lines!\n");
    logPrint("//\n");

    logPrint("load_tradespawns()\n");
    logPrint("{\n");
    logPrint("    level.tradespawns = [];\n");
    logPrint("    \n");

    count = level.devWeaponShops.size + level.devEquipmentShops.size;
    shop = "";
    type = "";
    for (i=0; i<count; i++) {
        modulo = i % 2;
        if (modulo == 0) {
            // even-numbered index, traditionally used for weapon shops
            shop = level.devWeaponShops[int(i / 2)];
            type = "weapon";
        } else {
            // odd-numbered index, traditionally used for equipment shops
            shop = level.devEquipmentShops[int((i - 1) / 2)];
            type = "equipment";
        }

        x = shop.origin[0];
        y = shop.origin[1];
        z = shop.origin[2];
        rho = shop.angles[0];
        phi = shop.angles[1];

        logPrint("    level.tradespawns["+i+"] = spawnstruct();  // spec'd for "+type+" shop\n");
        logPrint("    level.tradespawns["+i+"].origin = ("+x+","+y+","+z+");\n");
        logPrint("    level.tradespawns["+i+"].angles = ("+rho+","+phi+",0);\n");
    }

    logPrint("    \n");
    logPrint("    level.tradeSpawnCount = level.tradespawns.size;\n");
    logPrint("}\n");

    iPrintLnBold("Tradespawn data written to the server log.");
}

/**
 * @brief UMI writes entities with defined classname and/or targetname properties to the server log
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
devDumpEntities()
{
    debugPrint("in _umi::devDumpEntities()", "fn", level.nonVerbose);

    ents = getentarray();
    for (i=0; i<ents.size; i++) {
        if (isDefined(ents[i].classname)) {
            noticePrint(i + ": classname: " + ents[i].classname);
        }
        if (isDefined(ents[i].targetname)) {
            noticePrint(i + ": targetname: " + ents[i].targetname);
        }
    }
}

/**
 * @brief UMI to build equipment stores by tradespawns
 *
 * @param equipmentShops string Space-separated list of tradespawn array indices,
 * e.g. @code buildWeaponShopsByTradespawns("1 3 5 7"); @endcode
 *
 * @pre tradespawns have been loaded into level.tradespawns
 * @returns nothing
 * @since RotU 2.2.1
 */
buildShopsByTradespawns(equipmentShops, havePrefabModels)
{
    debugPrint("in _umi::buildShopsByTradespawns()", "fn", level.nonVerbose);

    if (!isDefined(havePrefabModels)) {havePrefabModels = false;}

    noticePrint("Map: RotU prefers _umi::buildShopsByTargetname(targetname).");
    noticePrint("Map: You may call _umi::modName() to determine which mod is trying to load the map.");

    shops = strTok(equipmentShops, " ");
    if (!isDefined(level.tradespawns[int(shops[0])])) {
        errorPrint("Map: No equipment shop tradespawns defined, or tradespawns haven't been loaded().");
        return;
    }

    for (i=0; i<shops.size; i++) {
        tradespawn = level.tradespawns[int(shops[i])];
        shop = spawn("script_model", tradespawn.origin);
        if (isDefined(shop)) {
            shop.angles = tradespawn.angles;
            shop setModel("ad_sodamachine");
        }

        // a column vector for the xmodel's centroid
        centroid = zeros(2,1);
        // 20.2 is approx. x-coord of 2-D centroid of xmodel, i.e. x bar
        setValue(centroid,1,1,20.2);
        // 15.8 is approx. y-coord of 2-D centroid of xmodel, i.e. y bar.  Negative
        // sign is needed due to location of origin in the xmodel
        setValue(centroid,2,1,-15.8);
        // phi is the angle the xmodel is rotated through
        phi = tradespawn.angles[1];
        // create standard rotation matrix
        A = eye(2);
        setValue(A,1,1,cos(phi));
        setValue(A,1,2,-1*sin(phi));
        setValue(A,2,1,sin(phi));
        setValue(A,2,2,cos(phi));
        // apply the rotation matrix
        R = matrixMultiply(A, centroid);
        // now (x,y) hold the proper rotated position offset relative to tradespawn.origin
        x = value(R,1,1);
        y = value(R,2,1);
        level scripts\players\_usables::addUsable(shop, "extras", "Press [USE] to buy upgrades!", 96);
        createTeamObjpoint(tradespawn.origin + (x,y,85), "hud_ammo", 1);

        // spawn a solid trigger_radius to simulate xmodel actually being solid
        level.solid = spawn("trigger_radius", (0, 0, 0), 0, 22, 122 );
        level.solid.origin = tradespawn.origin + (x,y,0);
        level.solid.angles = tradespawn.angles;
        level.solid setContents(1);
    }
}

/**
 * @brief UMI to build equipment shops by targetname
 *
 * @param targetname string The name of the entities' targetname attribute,
 * e.g. @code buildShopsByTargetname("weaponupgrade"); @endcode
 *
 * "weaponupgrade" is the targetname traditionally used by RotU
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
buildShopsByTargetname(targetname)
{
    debugPrint("in _umi::buildShopsByTargetname()", "fn", level.nonVerbose);

    ents = getentarray(targetname, "targetname");
    if (ents.size == 0) {
        errorPrint("Map: No equipment shops (entities matching targetname: " + targetname + ") found.");
        return;
    }

    for (i=0; i<ents.size; i++) {
        ent = ents[i];
        level scripts\players\_usables::addUsable(ent, "extras", "Press [USE] to buy upgrades!", 96);
        createTeamObjpoint(ent.origin+(0,0,72), "hud_ammo", 1);
    }
}

/**
 * @brief UMI to build weapons shop/upgrade by targetname
 *
 * @param targetname string The name of the entities' targetname attribute,
 * e.g. @code buildWeaponShopsByTargetname("ammostock"); @endcode
 * "ammostock" is the targetname traditionally used by RotU
 * @param loadTime int ???
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
buildWeaponShopsByTargetname(targetname, loadTime)
{
    debugPrint("in _umi::buildWeaponShopsByTargetname()", "fn", level.nonVerbose);

    ents = getentarray(targetname, "targetname");
    if (ents.size == 0) {
        errorPrint("Map: No weapon shops (entities matching targetname: " + targetname + ") found.");
        return;
    }

    for (i=0; i<ents.size; i++) {
        ent = ents[i];
        ent.loadtime = loadTime;
        if (level.ammoStockType == "weapon") {
            level scripts\players\_usables::addUsable(ent, "ammobox", "Press [USE] for a weapon! (^1"+level.dvar["surv_waw_costs"]+"^7)", 96);
            createTeamObjpoint(ent.origin+(0,0,72), "hud_weapons", 1);
        } else if (level.ammoStockType == "upgrade") {
            level scripts\players\_usables::addUsable(ent, "ammobox", "Press [USE] to upgrade your weapon!", 96);
            createTeamObjpoint(ent.origin+(0,0,72), "hud_weapons", 1);
        } else if (level.ammoStockType == "ammo") {
            level scripts\players\_usables::addUsable(ent, "ammobox", "Hold [USE] to restock ammo", 96);
        } else {
            errorPrint("level.ammoStockType isn't recognized.");
        }
    }
}

/**
 * @brief UMI to build weapons shop/upgrade by tradespawns
 *
 * @param weaponShops string Space-separated list of tradespawn array indices,
 * e.g. @code buildWeaponShopsByTradespawns("0 2 4 6"); @endcode
 *
 * @pre tradespawns have been loaded into level.tradespawns
 * @returns nothing
 * @since RotU 2.2.1
 */
buildWeaponShopsByTradespawns(weaponShops, havePrefabModels)
{
    debugPrint("in _umi::buildWeaponShopsByTradespawns()", "fn", level.nonVerbose);

    if (!isDefined(havePrefabModels)) {havePrefabModels = false;}

    noticePrint("Map: RotU prefers _umi::buildWeaponShopsByTargetname(targetname).");
    noticePrint("Map: You may call _umi::modName() to determine which mod is trying to load the map.");

    weapons = strTok(weaponShops, " ");
    if (!isDefined(level.tradespawns[int(weapons[0])])) {
        errorPrint("Map: No weapon shop tradespawns defined, or tradespawns haven't been loaded().");
        return;
    }

    for (i=0; i<weapons.size; i++) {
        tradespawn = level.tradespawns[int(weapons[i])];
        weaponupgrade = spawn("script_model", tradespawn.origin);
        if (isDefined(weaponupgrade)) {
            weaponupgrade.angles = tradespawn.angles;
            weaponupgrade setModel("com_plasticcase_green_big");

            // spawn a solid trigger_radius to simulate xmodel actually being solid
            level.solid = spawn("trigger_radius", (0, 0, 0), 0, 21, 27 );
            level.solid.origin = tradespawn.origin;
            level.solid.angles = tradespawn.angles;
            level.solid setContents(1);

            level scripts\players\_usables::addUsable(weaponupgrade, "ammobox", "Press [USE] to upgrade your weapon!", 96);
            createTeamObjpoint(tradespawn.origin + (0,0,72), "hud_weapons", 1);
        }
    }
}

/**
 * @brief UMI converts BTD/ROZO waypoints into RotU waypoints
 *
 * @pre waypoints loaded into memory in level.waypoints
 * @returns nothing
 * @since RotU 2.2.1
 */
convertToNativeWaypoints()
{
    debugPrint("in _umi::convertToNativeWaypoints()", "fn", level.lowVerbosity);

    if ((isDefined(level.WpCount)) && (level.WpCount > 0)) {
        noticePrint("Map: Native waypoints are already loaded, nothing to convert.");
        return;
    }
    fileName =  "waypoints/"+ tolower(getdvar("mapname")) + "_wp.csv";
    testCount = int(TableLookup(fileName, 0, 0, 1));
    if ((isDefined(testCount)) && (testCount > 0)) {
        if ((isDefined(level.preferBtdWaypoints)) && (!level.preferBtdWaypoints)) {
            noticePrint("Map: Native waypoints will be loaded from the fast file, nothing to convert.");
            return;
        }
    }
    if (level.waypoints.size == 0) {
        errorPrint("Map: No waypoints loaded in level.waypoints to convert.");
        return;
    }

    level.Wp = [];
    level.WpCount = 0;

    level.WpCount = level.waypoints.size;
    // Add in all of the waypoints
    for (i=0; i<level.WpCount; i++) {
        waypoint = spawnstruct();
        level.Wp[i] = waypoint;

        waypoint.origin = level.waypoints[i].origin;
        waypoint.isLinking = false;
        waypoint.ID = i;
    }
    // Now link the waypoints
    for (i=0; i<level.WpCount; i++) {
        waypoint = level.Wp[i];
        waypoint.linkedCount = level.waypoints[i].childCount;
        //         noticePrint("waypoint: " + i + " origin: " + waypoint.origin);
        for (j=0; j<waypoint.linkedCount; j++) {
            waypoint.linked[j] = level.Wp[level.waypoints[i].children[j]];
            //             noticePrint("waypoint: " + i + " is linked to waypoint " + level.waypoints[i].children[j]);
        }
        // Error catching
        if (!isdefined(waypoint.linked)) {
            iprintlnbold("^1UNLINKED WAYPOINT: " + waypoint.ID + " AT: " +  waypoint.origin);
        }
    }

    // Now that the ROZO waypoints are in memory in RotU format, we can free the
    // memory used by the ROZO waypoints
    level.waypoints = [];
}

/**
 * @brief UMI to build zombie spawn points by the entities' classname property
 *
 * @param classname string The value of the entities' classname property
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
buildZombieSpawnsByClassname(classname)
{
    debugPrint("in _umi::buildZombieSpawnsByClassname()", "fn", level.nonVerbose);

    ents = getEntArray(classname, "classname");
    if (ents.size == 0) {
        errorPrint("Map: No zombie spawn points (entities matching classname: " + classname + ") found.");
        return;
    }
    for (i=0; i<ents.size; i++) {
        count = i + 1;
        // set targetname property of the spawnpoints so they work with RotU
        ents[i].targetname = "spawngroup"+count;
        buildZombieSpawnByTargetname(ents[i].targetname, 1);
    }
}

/**
 * @brief UMI to build a zombie spawn point by an entity's targetname property
 *
 * @param targetname string The value of the entities' targetname property
 * @param priority int A zombie has a (priority / totalPriority) chance of being spawned here
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
buildZombieSpawnByTargetname(targetname, priority)
{
    debugPrint("in _umi::buildZombieSpawnByTargetname()", "fn", level.nonVerbose);

    ents = getentarray(targetname, "targetname");
    if (ents.size == 0) {
        errorPrint("Map: No zombie spawn point (entity matching targetname: " + targetname + ") found.");
        return;
    }

    scripts\gamemodes\_survival::addSpawn(targetname, priority);
}

/**
 * @brief UMI to build player spawn points by entities' classname property
 *
 * @param classname string The value of the classname to use for player spawn points
 * @param enabled boolean ???
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
addPlayerSpawnsByClassname(classname, enabled)
{
    debugPrint("in _umi::addPlayerSpawnsByClassname()", "fn", level.lowVerbosity);

    // Do nothing, RotU doesn't need to add player spawns
}

/**
 * @brief UMI to build player spawn points by entities' targetname property
 *
 * @param targetname string The value of the targetname to use for player spawn points
 * @param enabled boolean ???
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
addPlayerSpawnsByTargetname(targetname, enabled)
{
    debugPrint("in _umi::addPlayerSpawnsByTargetname()", "fn", level.lowVerbosity);

    // Do nothing, RotU doesn't need to add player spawns
}

/**
 * @brief UMI builds all barricades of the given targetname in the map
 *
 * @param targetname string The value of the entities' targetname property
 * @param partCount int The number of parts in barricades with this targetname
 * @param health int The initial and max hitpoints for the barricade
 * @param deathFx object A precached effect (via loadFx()) played when the barricade is destroyed
 * @param buildFx object A precached effect (via loadFx()) played when the barricade is rebuilt
 * @param dropAll boolean Optional, defaults to false
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
buildBarricadesByTargetname(targetname, partCount, health, deathFx, buildFx, dropAll)
{
    debugPrint("in _umi::buildBarricadesByTargetname()", "fn", level.lowVerbosity);

    if (!isdefined(dropAll)) {dropAll = false;}

    ents = getentarray(targetname, "targetname");
    for (i=0; i<ents.size; i++) {
        ent = ents[i];
        level.barricades[level.barricades.size] = ent;
        for (j=0; j<partCount; j++) {
            ent.parts[j] = ent getClosestEntity(ent.target + j);
            /// @bug if the part isn't defined, try skipping this part
            if (!isDefined(ent.parts[j])) {
                logPrint("j: " + j + " jth part is not defined.\n");
            }
            ent.parts[j].startPosition = ent.parts[j].origin;
            //             buildBarricade("staticbarricade", 4, 400, level.barricadefx,level.barricadefx);
        }
        ent.hp = int(health);
        ent.maxhp = int(health);;
        ent.partsSize = partCount;
        ent.deathFx = deathFx;
        ent.buildFx = buildFx;
        ent.occupied = false;
        ent.dropAll = dropAll;
        ent thread scripts\players\_barricades::makeBarricade();
    }
}

/**
 * @brief UMI builds all barricades of the given classname in the map
 *
 * @param classname string The value of the entities' classname property
 * @param partCount int The number of parts in barricades with this targetname
 * @param health int The initial and max hitpoints for the barricade
 * @param deathFx object A precached effect (via loadFx()) played when the barricade is destroyed
 * @param buildFx object A precached effect (via loadFx()) played when the barricade is rebuilt
 * @param dropAll boolean Optional, defaults to false
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
buildBarricadesByClassname(classname, partCount, health, deathFx, buildFx, dropAll)
{
    debugPrint("in _umi::buildBarricadesByClassname()", "fn", level.lowVerbosity);

    // Do nothing, RotU builds barricades by targetname
}

/**
 * @brief UMI builds weapons that can be picked up based on a targetname
 *
 * @param targetname string The name of the entities' targetname property
 * @param itemText string The English name of the weapon
 * @param weapon string The game name of the weapon, i.e. m14_mp
 * @param weaponType string The type of the weapon
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
buildWeaponPickupByTargetname(targetname, itemText, weapon, weaponType)
{
    debugPrint("in _umi::buildWeaponPickupByTargetname()", "fn", level.lowVerbosity);

    ents = getentarray(targetname, "targetname");
    for (i=0; i<ents.size; i++) {
        ent = ents[i];
        ent.myWeapon = weapon;
        ent.wep_type = weaponType;
        level scripts\players\_usables::addUsable(ent, "weaponpickup", "Press [USE] to pick up " + itemText, 96);
    }
}

/**
 * @brief UMI builds weapons that can be picked up based on a classname
 *
 * @param classname string The name of the entities' classname property
 * @param itemText string The English name of the weapon
 * @param weapon string The game name of the weapon, i.e. m14_mp
 * @param weaponType string The type of the weapon
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
buildWeaponPickupByClassname(classname, itemText, weapon, weaponType)
{
    debugPrint("in _umi::buildWeaponPickupByClassname()", "fn", level.lowVerbosity);

    // Do nothing, RotU doesn't build pickup weapons by classname
}

/**
 * @brief Sets whether the BTD waypoints are preferred if both BTD and CSV waypoints are available
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
setPreferBtdWaypoints(value)
{
    debugPrint("in _umi::setPreferBtdWaypoints()", "fn", level.lowVerbosity);

    level.preferBtdWaypoints = value;
}

/**
 * @brief UMI stops loading the map until the first player is actually ready to play
 *
 * Call this function before calling any map functions that require at least one
 * player to be in the game.
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
waitUntilFirstPlayerSpawns()
{
    debugPrint("in _umi::waitUntilFirstPlayerSpawns()", "fn", level.lowVerbosity);

    noticePrint("Map: First call to wait(), it is now too late to precache models or load fx.");
    wait .5;

    scripts\gamemodes\_gamemodes::initGameMode();

    while (level.activePlayers == 0) {
        wait .5;
    }
}

/**
 * @brief UMI begins the actual gameplay
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
startGame()
{
    debugPrint("in _umi::startGame()", "fn", level.nonVerbose);

    scripts\gamemodes\_survival::beginGame();
}

/**
 * @brief UMI deletes all entities with the given classname property
 *
 * @param classname string The value of the entities' classname property
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
deleteEntitiesByClassname(classname)
{
    debugPrint("in _umi::deleteEntitiesByClassname()", "fn", level.nonVerbose);

    ents = getentarray(classname, "classname");
    for (i=0; i<ents.size; i++) {
        ents[i] delete();
    }
}

/**
 * @brief UMI deletes all entities with the given targetname property
 *
 * @param targetname string The value of the entities' targetname property
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
deleteEntitiesByTargetname(targetname)
{
    debugPrint("in _umi::deleteEntitiesByTargetname()", "fn", level.nonVerbose);

    ents = getentarray(targetname, "targetname");
    for (i=0; i<ents.size; i++) {
        ents[i] delete();
    }
}

/**
 * @brief UMI deletes entities with a targetname of "oldschool_pickup"
 *
 * This deletes weapon and perk pickups on CoD4 stock maps, like mp_bog
 *
 * @returns nothing
 * @since RotU 2.2.1
 */
deletePickupItems()
{
    debugPrint("in _umi::deletePickupItems()", "fn", level.nonVerbose);

    deleteEntitiesByTargetname("oldschool_pickup");
}

//
// Unified Mapping Interface (UMI) Private Functions
//
// These functions should not be used by map makers, as they are subject to change
// and/or deletion without notice, at the consensus of the developers of the various
// mods.  They are generally utility functions that help make the interface work
// across various mods.
//

/**
 * @brief If both BTD and CVS waypoints are available, prefer the BTD waypoints?
 *
 * @returns boolean Whether the mapper or server operator prefers the BTD waypoints
 * @since RotU 2.2.1
 */
preferBtdWaypoints()
{
    debugPrint("in _umi::preferBtdWaypoints()", "fn", level.lowVerbosity);

    if (isDefined(level.preferBtdWaypoints)) {return level.preferBtdWaypoints;}
    else {return false;}
}

/**
 * @brief Is this map using the unified mapping interface?
 *
 * @returns boolean true if the map uses UMI, false otherwise
 * @since RotU 2.2.1
 */
isUmiMap()
{
    debugPrint("in _umi::isUmiMap()", "fn", level.lowVerbosity);

    /// @todo implement me
    return false;
}

/**
 * @brief Attempts to determine the name of the mod loading the map
 * @private
 *
 * @returns string The name of the mod, or an empty string if undetermined
 * @since RotU 2.2.1
 */
privateGuessModName()
{
    return "rotu";
}


//
// Unified Mapping Interface (UMI) Reserved Functions
//
// These functions are reserved for future use as public functions at the consensus
// of the developers of the various mods.  Calling them will not cause a compile
// or a runtime error, but they are't implemented. Any mod developer can implement
// and begin using one of these reserved functions at any time.
//
/**
 * @brief A hook for a function to initialize waypoints
 * @reserved
 *
 * @returns nothing
 */
initWaypoints()
{}

/**
 * @brief A hook for a function to initialize game setup
 * @reserved
 *
 * @returns nothing
 */
initSetup()
{}

/**
 * @brief A hook for a function to initialize barricades
 * @reserved
 *
 * @returns nothing
 */
initBarricades()
{}

/**
 * @brief A hook for a function to load waypoints
 * @reserved
 *
 * @returns nothing
 */
loadWaypoints()
{}

/**
 * @brief A hook for a function to load tradespawns
 * @reserved
 *
 * @returns nothing
 */
loadTradespawn()
{}


//
// RotU legacy functions
//
// These are the function calls in RotU _zombiescript.gsc file as of RotU 2.2.
// They are here for backwards compatibility for old maps.  These functions just
// forward the function call to the appropriate UMI function.
//

/**
 * @brief Builds weapon shops for RotU maps using old _zombiescript.gsc calls
 *
 * @param targetname string The value of the entities' targetname property
 * @param loadTime int ???
 *
 * @returns nothing
 */
buildAmmoStock(targetname, loadTime)
{
    debugPrint("in _umi::buildAmmoStock()", "fn", level.nonVerbose);

    setNativeMapType("rotu");
    level.isUmiMap = false;

    buildWeaponShopsByTargetname(targetname, loadTime);
}

/**
 * @brief Builds equipment shops for RotU maps using old _zombiescript.gsc calls
 *
 * @param targetname string The value of the entities' targetname property
 *
 * @returns nothing
 */
buildWeaponUpgrade(targetname)
{
    debugPrint("in _umi::buildWeaponUpgrade()", "fn", level.nonVerbose);

    setNativeMapType("rotu");
    level.isUmiMap = false;

    buildShopsByTargetname(targetname);
}

/**
 * @brief Builds a zombie spawn point for RotU maps using old _zombiescript.gsc calls
 *
 * @param targetname string The value of the entities' targetname property,
 * traditionally "spawngroup[n]", where n is an integer
 * @param priority int A zombie has a priority / totalPriority chance of being spawned here
 *
 * @returns nothing
 */
buildSurvSpawn(targetname, priority)
{
    debugPrint("in _umi::buildSurvSpawn()", "fn", level.nonVerbose);

    buildZombieSpawnByTargetname(targetname, priority);
}

/**
 * @brief Waits to start the game until the first player chooses their class and is spawned
 *
 * @returns nothing
 */
waittillStart()
{
    debugPrint("in _umi::waittillStart()", "fn", level.lowVerbosity);

    waitUntilFirstPlayerSpawns();
}

/**
 * @brief Begins the first wave of a RotU survival game
 *
 * @returns nothing
 */
startSurvWaves()
{
    debugPrint("in _umi::startSurvWaves()", "fn", level.nonVerbose);

    startGame();
}

/**
 * @brief Builds all barricades of the given targetname in the map
 *
 * @param targetname string The value of the entities' targetname property
 * @param partCount int The number of parts in barricades with this targetname
 * @param health int The initial and max hitpoints for the barricade
 * @param deathFx object A precached effect (via loadFx()) played when the barricade is destroyed
 * @param buildFx object A precached effect (via loadFx()) played when the barricade is rebuilt
 * @param dropAll boolean Optional, defaults to false
 *
 * @returns nothing
 */
buildBarricade(targetname, partCount, health, deathFx, buildFx, dropAll)
{
    debugPrint("in _umi::buildBarricade()", "fn", level.lowVerbosity);

    buildBarricadesByTargetname(targetname, partCount, health, deathFx, buildFx, dropAll);
}

/**
 * @brief Builds a weapon that can be picked up from an old RotU map using _zombiescript.gsc
 *
 * @param targetname string The name of the entities' targetname property
 * @param itemText string The English name of the weapon
 * @param weapon string The game name of the weapon, i.e. m14_mp
 * @param weaponType string The type of the weapon
 *
 * @returns nothing
 */
buildWeaponPickup(targetname, itemText, weapon, weaponType)
{
    debugPrint("in _umi::buildWeaponPickup()", "fn", level.lowVerbosity);

    buildWeaponPickupByTargetname(targetname, itemText, weapon, weaponType);
}

/// rotu unused ?
setWeaponHandling(id)
{
    debugPrint("in _umi::setWeaponHandling()", "fn", level.lowVerbosity);

    level.onGiveWeapons = id;
}

/// rotu unused ?
setSpawnWeapons(primary, secondary)
{
    debugPrint("in _umi::setSpawnWeapons()", "fn", level.lowVerbosity);

    level.spawnPrimary = primary;
    level.spawnSecondary = secondary;
}

/// rotu unused ?
buildParachutePickup(targetname)
{
    debugPrint("in _umi::buildParachutePickup()", "fn", level.lowVerbosity);

    ents = getentarray(targetname, "targetname");
    //for (i=0; i<ents.size; i++)
    //ents[i] thread scripts\players\_parachute::parachutePickup();
}

/// rotu unused ?
setWorldVision(vision, transitiontime)
{
    debugPrint("in _umi::setWorldVision()", "fn", level.lowVerbosity);

    visionSetNaked(vision, transitiontime);
    level.vision = vision;
}

/// rotu unused ?
setGameMode(mode)
{
    debugPrint("in _umi::setGameMode()", "fn", level.lowVerbosity);

    level.gameMode = mode;
    waittillframeend;
}

/// rotu unused ?
setPlayerSpawns(targetname)
{
    debugPrint("in _umi::setPlayerSpawns()", "fn", level.lowVerbosity);

    level.playerspawns = targetname;
}


//
// ROZO legacy functions
//
// These are the function calls used for mapping purposes as of ROZO 0.5.
// They are here for backwards compatibility for old maps.  These functions just
// forward the function call to the appropriate UMI function.
//

/**
 * @brief Builds zombie spawn points for old ROZO maps
 *
 * @returns nothing
 */
addDefaultZombieSpawns()
{
    debugPrint("in _umi::addDefaultZombieSpawns()", "fn", level.nonVerbose);

    buildZombieSpawnsByClassname("mp_dm_spawn");
}

/**
 * @brief Builds weapon shops and equipment shops using old ROZO calls
 *
 * @param weapons string Space-separated list of tradespawn array indices
 * @param shops string Space-separated list of tradespawn array indices
 *
 * e.g. @code placeShops("0 2 4 6", "1 3 5 7"); @endcode
 *
 * @returns nothing
 */
placeShops(weapons, shops)
{
    debugPrint("in _umi::placeShops()", "fn", level.nonVerbose);

    setNativeMapType("rozo");
    level.isUmiMap = false;

    // We need to force ROZO maps to waittillStart() or we can't create the usables
    waittillStart();

    buildWeaponShopsByTradespawns(weapons);
    buildShopsByTradespawns(shops);
}

/**
 * @brief Converts waypoints for old ROZO maps
 *
 * @returns nothing
 */
convertWaypoints()
{
    debugPrint("in _umi::convertWaypoints()", "fn", level.lowVerbosity);

    convertToNativeWaypoints();
}

/**
 * @brief Adds a new position as a default target for zombies that don't see a player
 *
 * @param origin A tuple containing the map position to be the default target
 *
 * @returns nothing
 */
zombieDefaultTarget(origin)
{
    debugPrint("in _umi::zombieDefaultTarget()", "fn", level.lowVerbosity);

    // Do nothing, RotU doesn't need to set default targets for zombies
}

mapThink()
{
    debugPrint("in _umi::mapThink()", "fn", level.lowVerbosity);

    // Do nothing, ROZO internal function
}

setPlayerModels()
{
    debugPrint("in _umi::setPlayerModels()", "fn", level.lowVerbosity);

    // Do nothing, ROZO internal function
}

getFreeStruct(structs, additional)
{
    debugPrint("in _umi::getFreeStruct()", "fn", level.lowVerbosity);

    // Do nothing, ROZO internal function
}

addDefaultPlayerSpawns(swap)
{
    debugPrint("in _umi::addDefaultPlayerSpawns()", "fn", level.lowVerbosity);

    // Do nothing, RotU doesn't need to add default player spawns
}

addPlayerSpawns(classname, enabled)
{
    debugPrint("in _umi::addPlayerSpawns()", "fn", level.lowVerbosity);

    // Do nothing, RotU doesn't need to add player spawns
}

